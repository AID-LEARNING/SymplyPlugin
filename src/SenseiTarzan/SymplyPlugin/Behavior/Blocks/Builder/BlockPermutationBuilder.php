<?php

/*
 *
 *            _____ _____         _      ______          _____  _   _ _____ _   _  _____
 *      /\   |_   _|  __ \       | |    |  ____|   /\   |  __ \| \ | |_   _| \ | |/ ____|
 *     /  \    | | | |  | |______| |    | |__     /  \  | |__) |  \| | | | |  \| | |  __
 *    / /\ \   | | | |  | |______| |    |  __|   / /\ \ |  _  /| . ` | | | | . ` | | |_ |
 *   / ____ \ _| |_| |__| |      | |____| |____ / ____ \| | \ \| |\  |_| |_| |\  | |__| |
 *  /_/    \_\_____|_____/       |______|______/_/    \_\_|  \_\_| \_|_____|_| \_|\_____|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author AID-LEARNING
 * @link https://github.com/AID-LEARNING
 *
 */

declare(strict_types=1);

namespace SenseiTarzan\SymplyPlugin\Behavior\Blocks\Builder;

use Generator;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\nbt\tag\ListTag;
use pocketmine\network\mcpe\convert\BlockStateDictionaryEntry;
use SenseiTarzan\SymplyPlugin\Behavior\Blocks\Permutation\Permutations;
use SenseiTarzan\SymplyPlugin\Behavior\Blocks\Property\BlockProperty;
use SenseiTarzan\SymplyPlugin\Behavior\Blocks\Trait\ITrait;
use SenseiTarzan\SymplyPlugin\Utils\Utils;
use function array_key_exists;
use function array_keys;
use function array_map;
use function array_reverse;
use function array_values;
use function is_string;

final class BlockPermutationBuilder extends BlockBuilder
{

	/** @var BlockProperty[] */
	private array $properties = [];

	/** @var Permutations[] */
	private array $permutations = [];

	/** @var ITrait[] */
	private array $traits = [];
	/**
	 * @param BlockProperty[] $properties
	 */
	public function setProperties(array $properties) : self
	{
		$this->properties = $properties;
		return $this;
	}

	/**
	 * @return $this
	 */
	public function addProperty(BlockProperty $property) : self
	{
		if (array_key_exists($name = $property->getName(), $this->properties))
			return $this;
		$this->properties[$name] = $property;
		return $this;
	}

	/**
	 * @return BlockProperty[]
	 */
	public function getProperties() : array
	{
		return $this->properties;
	}

	public function addTrait(ITrait $trait) : static
	{
		$name = $trait->getName();
		$this->traits[is_string($name) ? $name : $name->value] = $trait;
		return  $this;
	}

	public function getTraits() : array
	{
		return $this->traits;
	}

	/**
	 * Permet de mettre
	 * @return $this
	 */
	public function addPermutation(Permutations $permutation) : self
	{
		$this->permutations[] = $permutation;
		return $this;
	}

	/**
	 * @return Permutations[]
	 */
	private function getPermutations() : array
	{
		return $this->permutations;
	}

	public function getComponentsTag() : CompoundTag
	{
		return parent::getComponentsTag()->setTag("minecraft:on_player_placing", CompoundTag::create());
	}

	public function getPropertiesTag() : CompoundTag
	{
		$properties = parent::getPropertiesTag();
		$traits = new ListTag(array_map(static fn(ITrait $trait) => $trait->toNbt(), array_values($this->traits)), NBT::TAG_Compound);
		if (!$traits->empty())
			$properties->setTag("traits", $traits);
		return $properties
			->setTag("permutations", new ListTag(array_map(fn(Permutations $permutation) => $permutation->toNBT(), $this->getPermutations())))
			->setTag("properties", new ListTag(array_reverse(array_map(fn(BlockProperty $property) => $property->toNBT(), array_values($this->getProperties())))));// TODO: Change the autogenerated stub
	}

	public function toBlockStateDictionaryEntry() : Generator
	{
		$properties = $this->getProperties();
		foreach ($this->traits as $trait) {
			foreach ($trait->toBlockProperties() as $property) {
				$properties[$property->getName()] = $property;
			}
		}
		if (empty($properties))
		{
			yield from parent::toBlockStateDictionaryEntry();
		}else {
			$listBlockPropertyName = array_keys($properties);
			$datas = array_map(fn(BlockProperty $property) => $property->getValueInRaw(), array_values($properties));
			foreach (Utils::getCartesianProduct($datas) as $meta => $property) {
				$states = [];
				foreach ($property as $i => $data)
					$states[$listBlockPropertyName[$i]] = $data;
				yield new BlockStateDictionaryEntry($this->getNamespaceId(), $states, $meta);
			}
		}
	}
}
